<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>方程式解法アプリ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #app {
            display: flex;
            justify-content: space-between;
        }
        #input-section {
            width: 30%;
            padding: 20px;
            border-right: 1px solid black;
        }
        #equation-display {
            width: 100%;
            text-align: center;
            margin-top: 20px;
        }
        #graph-canvas {
            border: 1px solid black;
            width: 60%;
            height: auto;
        }
        .input-label {
            display: block;
            margin: 10px 0 5px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="input-section">
            <!-- 入力ボックス -->
            <label class="input-label">xの係数</label><input type="text" id="coef_x">
            <label class="input-label">x^2の係数</label><input type="text" id="coef_x2">
            <label class="input-label">x^3の係数</label><input type="text" id="coef_x3">
            <label class="input-label">x^4の係数</label><input type="text" id="coef_x4">
            <label class="input-label">x^5の係数</label><input type="text" id="coef_x5">
            <label class="input-label">定数項</label><input type="text" id="constant">
            <label class="input-label">許容誤差</label><input type="text" id="tolerance">
            <label class="input-label">二分法の初期値</label><input type="text" id="bisection_initial1"><input type="text" id="bisection_initial2">
            <label class="input-label">ニュートン法の初期値</label><input type="text" id="newton_initial">
            <div>
                <input type="radio" id="last_only" name="step_display" value="last_only" checked><label for="last_only">直前だけ残す</label>
                <input type="radio" id="all" name="step_display" value="all"><label for="all">全て残す</label>
            </div>
            <button id="execute">実行</button>
            <button id="show_steps" disabled>途中経過</button>
            <button id="reset" disabled>リセット</button>
        </div>
        <div id="equation-display"></div>
        <canvas id="graph-canvas" width="600" height="600"></canvas>
    </div>
    <script>
        let bisectSteps = [];
        let newtonSteps = [];
        let bisectCounter = 0;
        let newtonCounter = 0;

        function displayEquation() {
            let coef_x = document.getElementById('coef_x').value || 0;
            let coef_x2 = document.getElementById('coef_x2').value || 0;
            let coef_x3 = document.getElementById('coef_x3').value || 0;
            let coef_x4 = document.getElementById('coef_x4').value || 0;
            let coef_x5 = document.getElementById('coef_x5').value || 0;
            let constant = document.getElementById('constant').value || 0;

            let equation = `${coef_x5}x^5 + ${coef_x4}x^4 + ${coef_x3}x^3 + ${coef_x2}x^2 + ${coef_x}x + ${constant} = 0`;
            document.getElementById('equation-display').innerText = equation;
        }

        function f(x, coef) {
            return coef[5] * x ** 5 + coef[4] * x ** 4 + coef[3] * x ** 3 + coef[2] * x ** 2 + coef[1] * x + coef[0];
        }

        function fPrime(x, coef) {
            return 5 * coef[5] * x ** 4 + 4 * coef[4] * x ** 3 + 3 * coef[3] * x ** 2 + 2 * coef[2] * x + coef[1];
        }

        function drawFunction(coef) {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            ctx.beginPath();
            for (let x = -canvas.width / 2; x <= canvas.width / 2; x += 0.1) {
                let y = f(x / 50, coef) * 50;
                if (x === -canvas.width / 2) {
                    ctx.moveTo(x + canvas.width / 2, -y + canvas.height / 2);
                } else {
                    ctx.lineTo(x + canvas.width / 2, -y + canvas.height / 2);
                }
            }
            ctx.stroke();
        }

        function drawStep(step, method) {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const xCenter = canvas.width / 2;
            const yCenter = canvas.height / 2;

            ctx.strokeStyle = method === 'bisection' ? 'blue' : 'red';

            if (method === 'bisection') {
                let x1 = step[0] * 50 + xCenter;
                let x2 = step[1] * 50 + xCenter;
                ctx.beginPath();
                ctx.moveTo(x1, 0);
                ctx.lineTo(x1, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x2, 0);
                ctx.lineTo(x2, canvas.height);
                ctx.stroke();
            } else if (method === 'newton') {
                let x = step[0] * 50 + xCenter;
                let y = -step[1] * 50 + yCenter;
                ctx.beginPath();
                ctx.moveTo(x, yCenter);
                ctx.lineTo(x, y);
                ctx.lineTo(xCenter, y);
                ctx.stroke();
            }
        }

        function bisectionMethod(a, b, tol, coef) {
            let fa = f(a, coef);
            let fb = f(b, coef);

            if (fa * fb >= 0) {
                console.log('The function must have different signs at a and b');
                return null;
            }

            let m = (a + b) / 2;
            let fm = f(m, coef);

            while (Math.abs(fm) > tol) {
                if (fa * fm < 0) {
                    b = m;
                } else {
                    a = m;
                }
                m = (a + b) / 2;
                fm = f(m, coef);
                bisectSteps.push([a, b]);
            }

            return m;
        }

        function newtonMethod(x0, tol, coef) {
            let x = x0;
            let fx = f(x, coef);
            let fpx = fPrime(x, coef);

            while (Math.abs(fx) > tol) {
                x = x - fx / fpx;
                fx = f(x, coef);
                fpx = fPrime(x, coef);
                newtonSteps.push([x, fx]);
            }

            return x;
        }

        function resetApp() {
            bisectSteps = [];
            newtonSteps = [];
            bisectCounter = 0;
            newtonCounter = 0;

            document.getElementById('equation-display').innerText = '';
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            document.getElementById('show_steps').disabled = true;
            document.getElementById('reset').disabled = true;
        }

        function downloadSteps() {
            let content = 'Bisection Method Steps:\n';
            bisectSteps.forEach((step, index) => {
                content += `Step ${index + 1}: a=${step[0]}, b=${step[1]}\n`;
            });
            content += '\nNewton Method Steps:\n';
            newtonSteps.forEach((step, index) => {
                content += `Step ${index + 1}: x=${step[0]}, f(x)=${step[1]}\n`;
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'steps.txt';
            link.click();
        }

        document.getElementById('execute').addEventListener('click', () => {
            let coef = [
                parseFloat(document.getElementById('constant').value) || 0,
                parseFloat(document.getElementById('coef_x').value) || 0,
                parseFloat(document.getElementById('coef_x2').value) || 0,
                parseFloat(document.getElementById('coef_x3').value) || 0,
                parseFloat(document.getElementById('coef_x4').value) || 0,
                parseFloat(document.getElementById('coef_x5').value) || 0,
            ];
            let tol = parseFloat(document.getElementById('tolerance').value) || 0;
            let bisect_a = parseFloat(document.getElementById('bisection_initial1').value);
            let bisect_b = parseFloat(document.getElementById('bisection_initial2').value);
            let newton_x0 = parseFloat(document.getElementById('newton_initial').value);

            displayEquation();
            drawFunction(coef);

            bisectSteps = [];
            newtonSteps = [];
            bisectCounter = 0;
            newtonCounter = 0;

            let bisect_root = bisectionMethod(bisect_a, bisect_b, tol, coef);
            let newton_root = newtonMethod(newton_x0, tol, coef);

            console.log('Bisection method root:', bisect_root);
            console.log('Newton method root:', newton_root);

            document.getElementById('show_steps').disabled = false;
            document.getElementById('reset').disabled = false;
        });

        document.getElementById('show_steps').addEventListener('click', () => {
            const displayMode = document.querySelector('input[name="step_display"]:checked').value;
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            if (displayMode === 'last_only') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFunction(coef);

                if (bisectCounter < bisectSteps.length) {
                    drawStep(bisectSteps[bisectCounter], 'bisection');
                    bisectCounter++;
                }

                if (newtonCounter < newtonSteps.length) {
                    drawStep(newtonSteps[newtonCounter], 'newton');
                    newtonCounter++;
                }
            } else if (displayMode === 'all') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFunction(coef);

                bisectSteps.forEach((step, index) => {
                    drawStep(step, 'bisection');
                });

                newtonSteps.forEach((step, index) => {
                    drawStep(step, 'newton');
                });
            }
        });

        document.getElementById('reset').addEventListener('click', resetApp);
        document.getElementById('show_steps').addEventListener('click', downloadSteps);
    </script>
</body>
</html>
